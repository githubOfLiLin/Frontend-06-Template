学习笔记
### 解析 HTML，构建 DOM 树
使用 FSM (Finite State Machine 有限状态机)实现 HTML 的解析
HTML 文档中，已经规定了 HTML 的状态
Toy browser 只挑选部分状态来实现

**三种标签:**   
* 开始标签
* 结束标签
* 自封闭标签

**paser 工作：**   
* 在状态机中，除了状态迁移还需要加入业务逻辑   
paser 创建 token，把字符加到 token 上，之后 emit token
* 在标签结束状态提交 token（开始标签和结束标签结束的时候）

属性解析：     
* 属性分为单引号、双引号、无引号三种写法，故需要多种处理
* 处理方法与处理标签类似，用一个全局变量存储当前的属性，最后把 token emit

**语法分析，构建 DOM 树**   
栈--树   
* 从标签构建 DOM树的基本思想是使用栈结构
* 遇到开始标签入栈，遇到结束标签出栈
* 自封闭元素可认为入栈后即可出栈
* 任何元素的父元素可认为是它入栈之前的栈顶元素

### CSS 解析

**收集 css 规则**   
* 遇到 style 标签时，把 CSS 规则保存起来
* 调用 css paser 分析 css 规则
* 需要研究 css 这个库解析 css 规则的格式

**调用 css 规则**   
* 当创建一个元素是，即遇到 startTag 时，立即计算它的CSS
* 理论上我们分析一个元素时，所有 CSS 规则已经收集完毕
* 在真实的浏览器中，可能遇到写在 body 的 style 标签，可能会需要重新计算css，toy-browser 忽略了这种情况

**获取父元素序列**
* 在 computedCss 函数中，只有知道了当前元素的所有父元素，才能知道元素与规则是否匹配
* 从 startTag 处的 stack 即可知道该元素的所有父元素
* 因为我们首先获取的是当前元素，因此获得和计算父元素匹配的顺序是"由内向外"。

**选择器与元素的匹配**
* 选择器和当前元素的父元素的匹配顺序是一样的，都需要从内向外
* 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

**简单选择器与一个元素匹配**
* 根据选择器的类型计算其是否与元素匹配

**计算 computed css 属性**
* 一旦选择器匹配上了当前元素，则去将改选择器下的规则添加到元素上

**优先级**
规则如下：
```
[inline,id,class,tag]
div div #id
[0,1,0,2]
div #id1 #id2
[0,2,0,1]
```
先比较高位，高位相等再比较低位。   
* css 根据优先级和后来优先规则覆盖
* 优先级是个四元组，越左边优先级越高
* 一个 css 规则的优先级根据其所包含的简单选择器相加而得