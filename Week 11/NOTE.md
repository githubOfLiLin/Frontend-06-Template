学习笔记
### css 总体结构：
* @charset 字符集
* @import
* rules
  * @media
  * @page
  * rule

### At-rules
* @charset 指定样式表中使用的字符编码
* @iimport 用于从其他样式表导入样式规则
* @media 可用于基于一个或多个媒体查询的结果来应用样式表的一部分。使用它可以指定一个媒体查询和一个 css 块。当且仅当该媒体查询与正在使用其内容的设备匹配时才应用 css 块中的规则。  
* @page 分页
* @counter-style 可以自定义 counter 的样式。一个 @counter-style 规则定义了如何把一个计数器的值转化为字符串表示。可以在写列表时自定义列表前的计数器样式。   
* @keyframes 通过在动画序列中定义关键帧的样式来控制 css 动画序列的关键步骤。与 transition 相比，关键帧 keyframes 可以控制动画的中间步骤。   
* @font-face 可以自定义字体。字体能从远程服务器或者用户本地安装的自己加载。可以消除对用户电脑字体的依赖。   
* @supports 
* @namespace 命名空间

### 普通 css 规则的结构
* 选择器
* 规则声明
  * key
  * value

1. 选择器   
  a. 分组选择器（逗号分隔)   
  b. combinator(组合器): +(直接相邻兄弟选择器)，>(父子选择器)，~(一般兄弟选择器)，空格(子孙选择器)   
  c. 简单选择器：*通用选择器、类选择器、id选择器、标签选择器、属性选择器、伪类选择器、伪元素选择器(不用没有这个元素，用了就会多一个元素出来)、:not()
2. 声明   
知识点：   
自定义属性(也被称作 css 变量或级联变量)，使用'--'开头来定义变量，用var()函数来获取变量的值。   
value中可以使用一些函数：calc() min() max() attr() linear-gradient()等   

### 选择器
* 简单选择器
  * '*' 通用选择器
  * 类型选择器
  * 类选择器
  * id 选择器
  * 属性选择器 [attr=value]
  * 伪类选择器 :hover
  * 伪元素选择器 ::before
* 复合选择器
  * 多个简单选择器紧挨着写 表示同时匹配多个简单选择器
  * 通用选择器‘*’ 以及类型选择器必须在最前面
* 复杂选择器
  * +(直接相邻兄弟选择器)
  * >(父子选择器)
  * ~(一般兄弟选择器)
  * 空格(子孙选择器) 
* 选择器列表：多个复杂选择器由逗号连接   

### 选择器的优先级
实际上是对一个选择器里包含的所有简单选择器进行计数
规则：
以下选择器优先级依次递增：
1. 类型选择器、伪元素选择器
2. 类选择器、伪类选择器、属性选择器
3. id 选择器
4. !importent
注：通用选择器'*'、关系选择符:> ~ + 空格、否定伪类:not()对优先级没有影响，但:not()括号里面的选择器对优先级是会影响优先级的。   

### 伪类选择器
1. 链接/行为
  * :any-link 匹配任何的超链接
  * :link 匹配没有访问过的超链接
  * :visited 匹配访问过的超链接
  * :hover 
  * :active 激活状态
  * :focus 获得焦点
  * :target 表示链接到的当前的目标 给作为锚点的 a 标签使用的
2. 树结构  
  * :empty 表示这个元素是否有子元素
  * :nth-child 表示这个元素是父元素的第几个 child，可以在里面写奇偶，以及4N+1,3N+1等复杂的表达式
  * :nth-last-child 与:nth-child 相似，不过是从后向前数
  * :first-child :last-child :only-child 
注： :nth-last-child、 :last-child和:only-child 实际上破坏了计算 css 的时机，虽然可以实现，但是性能可能不会很好，尽量少用。   
3. 逻辑型
  * :not() 目前只支持在里面写简单选择器与复合选择器，不支持复杂选择器
  * :where :has (css4) 

### 伪元素选择器
* ::before
* ::after
* ::first-line 在块级元素的第一行应用样式，第一行的长度取决于多种因素：元素宽度、文档宽度、字体大小等
* ::first-letter 第一个字母应用样式 (比如用于将第一个字母放大)
前两种伪元素是相当于通过选择器去向界面上添加了一个不存在的元素。   
后两种使用一个不存在的元素将一部分文字括起来。比如::first-letter
```
<div><::first-letter>a</::first-letter>sjgdfjhvsv</div>
```   
所以它并没有匹配真实存在的元素，而是使用一个不存在的元素去将目标文本包括进去。然后去设置这个伪元素的样式。  

### match
我的思路：   
1. 主要用了状态机的思想，解析 selector, 将id,class,tagName,parent,祖先,父元素,兄弟，直接相邻兄弟保存在对象中。同时祖先,父元素,兄弟，直接相邻兄弟也是相同结构的对象。这里也用到了递归状态机的思想。   
2. 根据解析出的selector，来获取element上对应的属性，与selector进行匹配，匹配不到则返回 false, 全部匹配则返回 true.   





