## 学习笔记
本周课程主要实现了寻路问题。   
在地图上给定一个起点和终点怎么找到一条从起点到终点的路径。   

### 首先第一节课是实现一个地图，包括：   
- 表示地图上的格子的数据结构：使用一位数组，进行两层循环来表示行和列，是用 `100*row+col` 来表示 100*100 地图上的 row 行 col 列的格子。   
- 向地图上添加障碍点的功能：在循环内将格子添加到地图上的之后，同时监听鼠标移动事件，当鼠标的坐标在该格子内，将该格子的背景色置为黑色。      
采用箭头函数以及闭包，使得在循环结束后，触发鼠标事件时仍然能访问到格子元素。   
- 清除障碍点：mousedown事件中，`e.which`查看是左键按下还是右键按下，左键按下则在鼠标移动时将点置为黑色，反之置为白色。达到即可画点又可清除点的效果。   
这里要注意`e.preventDefault`来关闭鼠标右键默认执行的动作。

### 第二节课：给一个起点和终点，如何达到终点：广度优先搜索   
主要思路是：从起点出发，第一步可以走到它的上下左右四个点。那接下来从它的上下左右四个点再出发，又可以继续扩散。直到抵达终点。   

实现方法：使用队列数据结构(array push 和 shift)实现广度优先搜索。先将起点加入队列。
在循环体中，shift取出队列中的第一个元素，寻找其上下左右四个点加入队列(其中如果是边界点、障碍点或已找过的点则不再加入队列,通过每次插入队列的时候，在地图数组中将该点置为2来标记已找过的点)，直到shift的点的横纵坐标都与终点相同，结束循环，找到终点。若队列中的点都被shift出来找过相邻点却依然没有找到终点，则结束循环，返回false。

### 第三节：若找到了终点，怎么标记出来从起点走到终点的路径
思路：上节课通过从相邻点不断扩散走到了终点，那么要找出路径，就需要判断是哪个点的上下左右四个点之一是终点，然后不断回溯，找前一个点，直到起点，即找到了路径。   

实现：每次插入相邻点的时候，记录一下他们的中心点。老师讲了一种很巧妙的方法，不需要开新的内存。即插入点的时候，将该点在map数组中的值记为它的中心点的坐标。   
这样在找到终点之后，去map数组里找改点坐标对应的数组元素的值，即是他的前一个点，逐步遍历，找到路径。有意思～

### 第四节、第五节 启发式搜索
找最优路径。   
写一个新的数据结构，即在每次shift的时候，都去取至终点距离最小的点。通过数组利用排序的思想来实现这个数据结构。   
这里删除改目标点的时候用了一个小技巧：使用slice 删除的平均时间复杂度是O(n),老师通过将该点的值置为数组最后一个点的值，之后将最后一个点pop出去，返回min来实现，复杂度为O(1)



